<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://kojunhee.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://kojunhee.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-워터폴,에자일" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/12/워터폴,에자일/" class="article-date">
  <time datetime="2018-11-11T15:00:00.000Z" itemprop="datePublished">2018-11-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/softwareEngineering/">softwareEngineering</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/12/워터폴,에자일/">워터폴,에자일</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Waterfall-Model"><a href="#Waterfall-Model" class="headerlink" title="Waterfall Model"></a>Waterfall Model</h2><p>순차적인 소프트웨어 개발 프로세스이다.</p>
<p>개발의 흐름이 마치 폭포수처럼 지속적으로 아래로 향하는 것처럼 보이는 데서 이름이 붙여졌다. </p>
<p>이 폭포수 모델의 흐름은 다음과 같다.</p>
<ol>
<li>요구사항 분석</li>
<li>설계</li>
<li>구현</li>
<li>유지보수</li>
</ol>
<h2 id="Agile-Model"><a href="#Agile-Model" class="headerlink" title="Agile Model"></a>Agile Model</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/agile01.png" alt="img"></p>
<p>개발과 즉시 피드백을 받아 유동적으로 개발하는 방법론이다.</p>
<p>애자일 모델은 전체적인 플랜을 짜고 문서를 통해 주도해 나가던 과거의 방식(워터폴 모델)과 달리 </p>
<p>앞을 예측하며 개발하지 않고, 일정한 주기를 가지고 끊임없이 프로토 타입을 만들어 내며 필요할 때마다 요구사항을 더하고 수정</p>
<p>하여 커다란 소프트웨어를 개발해 나가는 방식이다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ko.wikipedia.org/wiki/%ED%8F%AD%ED%8F%AC%EC%88%98_%EB%AA%A8%EB%8D%B8" target="_blank" rel="noopener">https://ko.wikipedia.org/wiki/%ED%8F%AD%ED%8F%AC%EC%88%98_%EB%AA%A8%EB%8D%B8</a></p>
<p><a href="http://blog.rightbrain.co.kr/?p=5810" target="_blank" rel="noopener">http://blog.rightbrain.co.kr/?p=5810</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kojunhee.github.io/2018/11/12/워터폴,에자일/" data-id="cjp7vlcfz00j8zjx7ayr7s08k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-REST" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/12/REST/" class="article-date">
  <time datetime="2018-11-11T15:00:00.000Z" itemprop="datePublished">2018-11-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/12/REST/">REST</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="REST란"><a href="#REST란" class="headerlink" title="REST란"></a>REST란</h2><p>소프트웨어 아키텍처의 한 형식이다.</p>
<h2 id="구성-요소"><a href="#구성-요소" class="headerlink" title="구성 요소"></a>구성 요소</h2><ol>
<li><p>URI</p>
<p>자원의 주소이다.</p>
</li>
<li><p>HTTP Method</p>
<p>어떤 자원에 행할 수 있는 행위이다. CRDU로 나타낸다.</p>
<ul>
<li>POST : 해당 URI를 요청하면 리소스를 생성한다.</li>
<li>GET : 해당 리소스를 조회하고 해당 도큐먼트에 대한 자세한 정보를 가져온다.</li>
<li>PUT : 해당 리소스를 수정한다.</li>
<li>DELETE : 리소스를 삭제한다.</li>
</ul>
</li>
<li><p>Representation</p>
<p>자원의 URI에 특정 행위를 요청하면 그 결과로 Representation 을 응답 받는다. html, xml, text, json,<br>rss 등 다양한 형태로 표현될 수 있다.</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kojunhee.github.io/2018/11/12/REST/" data-id="cjp7vlcg100jdzjx79cbtosf4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-점근 표기법" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/11/점근 표기법/" class="article-date">
  <time datetime="2018-11-10T15:00:00.000Z" itemprop="datePublished">2018-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/dataStructure/">dataStructure</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/11/점근 표기법/">점근 표기법</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="시간-복잡도와-공간-복잡도"><a href="#시간-복잡도와-공간-복잡도" class="headerlink" title="시간 복잡도와 공간 복잡도"></a>시간 복잡도와 공간 복잡도</h2><ol>
<li>시간 복잡도 : 알고리즘의 수행시간 분석결과</li>
<li>공간 복잡도 : 알고리즘의 메모리 사용량에 대한 분석결과</li>
</ol>
<p>알고리즘 성능평가는 시간 복잡도와 공간 복잡도를 계산하고 점근적 표기법으로 나타내면 된다.</p>
<h2 id="점근적-분석이란"><a href="#점근적-분석이란" class="headerlink" title="점근적 분석이란"></a>점근적 분석이란</h2><p>알고리즘의 수행 시간을 분석하기 위해, 항상 입력의 크기가 충분히 클 때에 대해서 분석하는 방법 </p>
<h2 id="점근적-표기법이란"><a href="#점근적-표기법이란" class="headerlink" title="점근적 표기법이란"></a>점근적 표기법이란</h2><p>점근적 증가율은 입력의 크기에 따라 함수가 증가하는 비율이다. 그 표기법을 점근적 표기법이라 한다.<br>세 가지가 있다.</p>
<ul>
<li>빅오 표기법</li>
<li>오메가 표기법</li>
<li>세타 표기법</li>
</ul>
<h2 id="빅오-표기법"><a href="#빅오-표기법" class="headerlink" title="빅오 표기법"></a>빅오 표기법</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/asymptonic01.png" alt="img"></p>
<p>f(n)을 O(g(n))이라고 표시한다. </p>
<p>이 때 g(n)를 f(n)의 점근 상한이라고 한다.</p>
<p>알고리즘 f(n)이 O(g(n))에 속한다면, f(n)의 계산복잡도는 최악의 경우라도 g(n)과 같거나 혹은 작다는 뜻이다.</p>
<p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/asymptonic011.png" alt="img"></p>
<h2 id="오메가-표기법"><a href="#오메가-표기법" class="headerlink" title="오메가 표기법"></a>오메가 표기법</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/asymptonic02.png" alt="img"></p>
<p>f(n)를 Ω(g(n))이라고 표시한다. </p>
<p>이 때 g(n)는 f(n)의 점근 하한이라고 한다. </p>
<p>알고리즘 f(n)의 계산복잡도가 Ω(g(n))에 속한다면, f(n)의 계산복잡도는 최선의 경우를 상정하더라도 g(n)과 같거나 혹은 크다는 뜻이다.</p>
<h2 id="세타-표기법"><a href="#세타-표기법" class="headerlink" title="세타 표기법"></a>세타 표기법</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/asymptonic03.png" alt="img"></p>
<p>f(n)을 Θ(g(n))이라고 표시한다. </p>
<p>g(n)은 f(n)의 점근적 상한과 하한의 교집합이라고 한다. </p>
<p>알고리즘 f(n)이 아무리 나쁘거나 좋더라도 그 계산복잡도는 g(n)의 범위 내에 있다는 뜻이다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ratsgo.github.io/data%20structure&amp;algorithm/2017/09/13/asymptotic/" target="_blank" rel="noopener">https://ratsgo.github.io/data%20structure&amp;algorithm/2017/09/13/asymptotic/</a></p>
<p><a href="http://ledgku.tistory.com/33" target="_blank" rel="noopener">http://ledgku.tistory.com/33</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kojunhee.github.io/2018/11/11/점근 표기법/" data-id="cjp7vlcfy00j6zjx71ndmzj8e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-선택정렬" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/11/선택정렬/" class="article-date">
  <time datetime="2018-11-10T15:00:00.000Z" itemprop="datePublished">2018-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/dataStructure/">dataStructure</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/11/선택정렬/">선택정렬</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="선택정렬이란"><a href="#선택정렬이란" class="headerlink" title="선택정렬이란"></a>선택정렬이란</h2><p>해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 정렬이다.</p>
<p>첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여 가장 작은 값을 찾아 첫 번째에 놓고, 두 번째 자료를 세 번째 자료부터 마지막 자료까지와 차례대로 비교하여 그 중 가장 작은 값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬을 수행한다.</p>
<p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/selectionSort01.png" alt="img"></p>
<h2 id="시간-복잡도"><a href="#시간-복잡도" class="headerlink" title="시간 복잡도"></a>시간 복잡도</h2><ol>
<li>for 루프는 n-1번 반복 되고</li>
<li>최소값을 찾기 위한 비교 횟수는 n-1, n-2, … , 2, 1</li>
<li>교환은 상수 시간 작업이므로</li>
</ol>
<p>T(n) = (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2 = O(n^2)</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://jongmin92.github.io/2017/11/06/Algorithm/Concept/basic-sort/" target="_blank" rel="noopener">https://jongmin92.github.io/2017/11/06/Algorithm/Concept/basic-sort/</a><br><a href="https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html" target="_blank" rel="noopener">https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kojunhee.github.io/2018/11/11/선택정렬/" data-id="cjp7vlcfx00j3zjx7zic72w58" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MongoDB" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/11/MongoDB/" class="article-date">
  <time datetime="2018-11-10T15:00:00.000Z" itemprop="datePublished">2018-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/database/">database</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/11/MongoDB/">MongoDB</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MonogoDB란"><a href="#MonogoDB란" class="headerlink" title="MonogoDB란"></a>MonogoDB란</h2><p>Document Database</p>
<h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul>
<li><p>db &gt; collection &gt; document &gt; key:value</p>
<p>( RDBMS : db &gt; table &gt; row &gt; column)</p>
</li>
<li><p>Schemaless</p>
<p>스키마란, 데이터베이스를 구성하는 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작 시<br>데이터 값들이 갖는 제약조건 등에 관해 전반적으로 정의하는 것.</p>
<p>MongoDB 는 이러한 스키마가 사전에 정의되지 않아도 된다. Document는 다른 필드를 가질 수 있다.</p>
</li>
<li><p>Document Oriented ( BSON format )</p>
<p>하나의 row에 하나의 Document를 저장한다.</p>
</li>
<li><p>Deep query ability</p>
<p>문서지향적 Query Language 를 사용. javascript expressions 으로 이해하기 쉽다.</p>
<p>(key-value queries / range queries / search queries / map reduce queries ..)</p>
</li>
<li><p>indexing</p>
<p>RDBMS인 MySQL에서 지원하는 대부분의 인덱스를 지원한다.</p>
<p>index는 메모리에 저장되기 때문에 메모리 크기에 영향을 많이 받는다.</p>
</li>
<li><p>auto-sharding</p>
<p>처음부터 자동으로 데이터를 분산하여 저장하며, 하나의 컬렉션처럼 사용할 수 있게 해준다. 수평적 확장 가능</p>
</li>
<li><p>replicication</p>
<p>간단한 설정만으로도 데이터 복제를 지원. 가용성 향상.</p>
</li>
<li><p>Read/Write 성능이 빠름</p>
<p>Write시에, Memory에 먼저 Write후에, 1분 단위로 Flushing하는 Write Back 방식을 쓴다.<br>즉 메모리에만 쓰면 되니까는 Write가 무지 빠르다. </p>
<p>단 Flushing전에 Fail이 되면 데이타 유실에 의해서 Consistency 가 깨지는 문제가 발생</p>
<p>Read시에, 파일의 Index를 메모리에 로딩해놓고 찾는다 (memory mapped file).</p>
</li>
<li><p>RDBMS와는 달리 데이터 간의 관계를 정의하지 않는다.</p>
<p>관계형 데이터베이스인 RDBMS는 데이터의 관계를 Foreign Key 등으로 정의하고, 이를 이용해서 Join 등<br>관계형 연산을 한다. </p>
<p>NoSQL은 데이터 간의 관계를 정의하지 않는다. 데이터 테이블은 그냥 하나의 테이블이며 각 테이블 간의 관<br>를 정의하지도 않고 일반적으로 테이블 간의 Join도 불가능하다.</p>
</li>
</ul>
<h2 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h2><ul>
<li><p>Flexibility </p>
<p>Schema-less라서 어떤 형태의 데이터라도 저장할 수 있다.</p>
</li>
<li><p>Performance </p>
<p>Read &amp; Write 성능이 뛰어나다. 캐싱이나 많은 트래픽을 감당할 때 써도 좋다.</p>
</li>
<li><p>Scalability </p>
<p>애초부터 스케일아웃 구조를 채택해서 쉽게 운용가능하다. Auto sharding 지원</p>
</li>
<li><p>Deep Query ability</p>
<p>문서지향적 Query Language 를 사용하여 SQL 만큼 강력한 Query 성능을 제공한다.</p>
</li>
<li><p>Conversion / Mapping</p>
<p>JSON형태로 저장이 가능해서 직관적이고 개발이 편리하다.</p>
</li>
</ul>
<h2 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h2><ul>
<li><p>정합성이 떨어지므로 트랜잭션이 필요한 경우에는 부적합하다. (ex. 금융, 결제, 회원정보 등)</p>
</li>
<li><p>JOIN이 없다. join이 필요없도록 데이터 구조화 필요</p>
</li>
<li><p>memory mapped file으로 파일 엔진 DB이다. 메모리 관리를 OS에게 위임한다. 메모리 크기가 성능을 좌우</p>
</li>
<li><p>SQL을 완전히 이전할 수는 없다.</p>
</li>
<li><p>B트리 인덱스를 사용하여 인덱스를 생성하는데, B트리는 크기가 커질수록 새로운 데이터를 입력하거나 삭제할<br>때 성능이 저하된다. 이런 B트리의 특성 때문에 데이터를 넣어두면 변하지않고 정보를 조회하는 데에 적합하다.</p>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://nicewoong.github.io/development/2018/02/10/mongodb-feature/" target="_blank" rel="noopener">https://nicewoong.github.io/development/2018/02/10/mongodb-feature/</a></p>
<p><a href="http://bcho.tistory.com/624?category=431296" target="_blank" rel="noopener">http://bcho.tistory.com/624?category=431296</a></p>
<p><a href="http://sjh836.tistory.com/98" target="_blank" rel="noopener">http://sjh836.tistory.com/98</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kojunhee.github.io/2018/11/11/MongoDB/" data-id="cjp7vlcfx00j1zjx7zhb2ug9e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-버블정렬" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/11/버블정렬/" class="article-date">
  <time datetime="2018-11-10T15:00:00.000Z" itemprop="datePublished">2018-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/dataStructure/">dataStructure</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/11/버블정렬/">버블정렬</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="버블정렬이란"><a href="#버블정렬이란" class="headerlink" title="버블정렬이란"></a>버블정렬이란</h2><p>서로 인접한 두 원소를 검사하여 정렬하는 알고리즘이다.<br>첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, … 이런 식으로 (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.<br><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/bubbleSort01.png" alt="img"></p>
<h2 id="시간-복잡도"><a href="#시간-복잡도" class="headerlink" title="시간 복잡도"></a>시간 복잡도</h2><ul>
<li>비교 횟수<br>최상, 평균, 최악 모두 일정하다.  n-1, n-2, … , 2, 1 번 = n(n-1)/2</li>
<li>교환 횟수<br>입력 자료가 역순으로 정렬되어 있는 최악의 경우, 한 번 교환하기 위하여 3번의 이동(SWAP 함수의 작업)이 필<br>요하므로 (비교 횟수 * 3) 번 = 3n(n-1)/2</li>
<li>T(n) = O(n^2)</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html" target="_blank" rel="noopener">https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kojunhee.github.io/2018/11/11/버블정렬/" data-id="cjp7vlcfw00izzjx7kehiiabn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-삽입정렬" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/11/삽입정렬/" class="article-date">
  <time datetime="2018-11-10T15:00:00.000Z" itemprop="datePublished">2018-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/dataStructure/">dataStructure</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/11/삽입정렬/">삽입정렬</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="삽입정렬이란"><a href="#삽입정렬이란" class="headerlink" title="삽입정렬이란"></a>삽입정렬이란</h2><p>배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다.</p>
<p>두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 후 자료가 삽입될 위치를 찾는다. 자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동시킨다.</p>
<p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/insertionSort01.png" alt="img"></p>
<h2 id="시간-복잡도"><a href="#시간-복잡도" class="headerlink" title="시간 복잡도"></a>시간 복잡도</h2><ol>
<li>for 루프는 n-1번 반복 되고</li>
<li>최악의 경우 데이터 삽입을 위한 비교는 i-1번 비교</li>
</ol>
<p>따라서 최악의 경우 T(n) = (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2 = O(n^2)</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ko.wikipedia.org/wiki/삽입_정렬" target="_blank" rel="noopener">https://ko.wikipedia.org/wiki/삽입_정렬</a><br><a href="https://jongmin92.github.io/2017/11/06/Algorithm/Concept/basic-sort/" target="_blank" rel="noopener">https://jongmin92.github.io/2017/11/06/Algorithm/Concept/basic-sort/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kojunhee.github.io/2018/11/11/삽입정렬/" data-id="cjp7vlcfv00iwzjx712d1jtqz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Heap" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/11/Heap/" class="article-date">
  <time datetime="2018-11-10T15:00:00.000Z" itemprop="datePublished">2018-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/dataStructure/">dataStructure</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/11/Heap/">Heap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Heap-이란"><a href="#Heap-이란" class="headerlink" title="Heap 이란"></a>Heap 이란</h2><p>우선순위 큐를 위한 완전이진트리</p>
<h2 id="우선순위-큐"><a href="#우선순위-큐" class="headerlink" title="우선순위 큐"></a>우선순위 큐</h2><p>데이터들이 우선순위를 가지고 있고, 우선순위가 높은 데이터가 먼저 출력되는 자료구조.<br>우선순위 큐는 배열, 연결리스트, 힙 으로 구현이 가능하다. 이 중에서 힙(heap)으로 구현하는 것이 가장 효율적.</p>
<h2 id="Heap의-종류"><a href="#Heap의-종류" class="headerlink" title="Heap의 종류"></a>Heap의 종류</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/heap01.png" alt="img"></p>
<ol>
<li>최대힙<br>부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리</li>
<li>최소힙<br>부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리</li>
</ol>
<h2 id="Heap의-구현"><a href="#Heap의-구현" class="headerlink" title="Heap의 구현"></a>Heap의 구현</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/heap02.png" alt="img"></p>
<p>배열로 구현한다.<br>부모 노드와 자식 노드의 관계는 다음과 같다.</p>
<ul>
<li>왼쪽 자식의 인덱스 = (부모의 인덱스) * 2</li>
<li>오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 + 1</li>
<li>부모의 인덱스 = (자식의 인덱스) / 2</li>
</ul>
<h2 id="Heap의-삽입"><a href="#Heap의-삽입" class="headerlink" title="Heap의 삽입"></a>Heap의 삽입</h2><ol>
<li>힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입한다.</li>
<li>새로운 노드를 부모 노드들과 교환해서 힙의 성질을 만족시킨다.</li>
</ol>
<h2 id="Heap의-삭제"><a href="#Heap의-삭제" class="headerlink" title="Heap의 삭제"></a>Heap의 삭제</h2><ol>
<li>최대 힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제된다.<br>최대 힙(max heap)에서 삭제 연산은 최댓값을 가진 요소를 삭제하는 것이다.<br>최소 힙(min heap)에서 삭제 연산은 최솟값을 가진 요소를 삭제하는 것이다.</li>
<li>삭제된 루트 노드에는 힙의 마지막 노드를 가져온다.</li>
<li>힙을 재구성한다.</li>
</ol>
<h2 id="Heap-정렬"><a href="#Heap-정렬" class="headerlink" title="Heap 정렬"></a>Heap 정렬</h2><p>최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법</p>
<h2 id="Heap-정렬의-시간-복잡도"><a href="#Heap-정렬의-시간-복잡도" class="headerlink" title="Heap 정렬의 시간 복잡도"></a>Heap 정렬의 시간 복잡도</h2><p>힙 트리의 전체 높이가 거의 log₂n(완전 이진 트리이므로)이므로 하나의 요소를 힙에 삽입하거나 삭제할 때 힙을 재정비하는 시간이 log₂n만큼 소요된다.</p>
<p>요소의 개수가 n개 이므로 전체적으로 O(nlog₂n)의 시간이 걸린다.</p>
<p>T(n) = O(nlog₂n)</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html" target="_blank" rel="noopener">https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kojunhee.github.io/2018/11/11/Heap/" data-id="cjp7vlcfv00iuzjx7c49kwz7z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-숫자 고르기" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/08/숫자 고르기/" class="article-date">
  <time datetime="2018-11-07T15:00:00.000Z" itemprop="datePublished">2018-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/08/숫자 고르기/">숫자 고르기</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://www.acmicpc.net/problem/2668" target="_blank" rel="noopener">https://www.acmicpc.net/problem/2668</a></p>
<h2 id="오답-풀이"><a href="#오답-풀이" class="headerlink" title="오답 풀이"></a>오답 풀이</h2><p><a href="https://github.com/KoJunHee/algorithm/blob/master/src/bj_2668/Main.java" target="_blank" rel="noopener">https://github.com/KoJunHee/algorithm/blob/master/src/bj_2668/Main.java</a></p>
<p>완전 탐색으로 풀었다. 가능한 모든 경우를 조사하였다. 깊이 들어갈 때 마다, 두 집합이 일치하는지, 깊이는 몇인지 체크한다. 시간 초과가 났다. 모든 경우를 완전 탐색으로 찾으며 푸는것이 아니란 것이다.</p>
<h2 id="정답-풀이"><a href="#정답-풀이" class="headerlink" title="정답 풀이"></a>정답 풀이</h2><p><a href="https://github.com/KoJunHee/algorithm/blob/master/src/bj_2668_02/Main.java" target="_blank" rel="noopener">https://github.com/KoJunHee/algorithm/blob/master/src/bj_2668_02/Main.java</a></p>
<p>사이클 여부를 조사한다. 다음 이동할 지점이 시작점이면 사이클을 이룬 것이다. 문제에서 주어진 예시를 그림으로 그려보자.</p>
<p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/dfscycle.png" alt="img"></p>
<p>1을 시작으로 dfs를 시작하자. 1 방문 체크를 한다. 다음 위치는 3이다. 3 방문 체크를 한다. 다음 위치는 1이다. 이미 방문한 곳이다. 시작점으로 돌아왔으니 싸이클을 이루었다. 시작점인 1을 리스트에 저장한다. 이번 dfs는 끝났다.</p>
<p>2를 시작으로 dfs를 시작하자. 2 방문 체크를 한다. 다음 위치는 1이다. 1 방문 체크를 한다. 다음 위치는 3이다. 3 방문 체크를 한다. 다음 위치는 1이다. 이미 방문한 곳이다. 이미 방문 한곳이 시작점이 아니기 때문에 사이클을 이루지 않는다. 이번 dfs는 끝났다.</p>
<p>이런 식으로 7을 시작으로 하는 dfs 까지 진행하고 리스트에 저장된 값을 출력한다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kojunhee.github.io/2018/11/08/숫자 고르기/" data-id="cjp7vlcfu00iszjx7khrocgse" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TCP:IP" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/08/TCP:IP/" class="article-date">
  <time datetime="2018-11-07T15:00:00.000Z" itemprop="datePublished">2018-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/network/">network</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/08/TCP:IP/">TCP/IP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="TCP-IP란"><a href="#TCP-IP란" class="headerlink" title="TCP/IP란"></a>TCP/IP란</h2><p>TCP/IP는, Transfer Control Protocol/Internet Protocol 의 줄임말이다. 컴퓨터와 컴퓨터가 통신하기 위한 통신 규약(Protocol)이다. TCP는 서버와 클라이언트간에 데이타를 신뢰성있게 전달하기 위해 만들어진 프로토콜이다. 데이터는 전송되는 과정에서 데이터가 유실, 손실되거나 순서가 뒤바뀌어 전달될 수 있다. TCP는 이를 검색하고 교정하여 순서를 재조합할 수 있도록 보장한다. IP는 전송할 데이터를 packet 단위로 나누어서 어디로 보낼 것인지 결정한다. 즉, TCP는 데이터의 정확성 확인을, IP는 패킷을 목적지까지 전송을 담당한다.</p>
<h2 id="OSI-7-계층"><a href="#OSI-7-계층" class="headerlink" title="OSI 7 계층"></a>OSI 7 계층</h2><p>OSI는 Open System Interconnection Reference Model의 줄임말이다. IOS에서 제안한 모델로, 시스템에 상관없이 서로의 시스템이 연결될 수 있도록 하는 모델이다. 다음과 같이, 7계층으로 구성되어 있다.</p>
<ol>
<li>Application Layer</li>
<li>Presentation Layer</li>
<li>Session Layer</li>
<li>Transport Layer</li>
<li>Network Layer</li>
<li>Data Link Layer</li>
<li>Pysical Layer</li>
</ol>
<p>컴퓨터와 컴퓨터 사이에 데이터 전송을 위해 위의 7 계층을 거쳐서 전송이 된다. </p>
<p>그런데 왜, 이렇게 계층화를 한 것일까 ? 각 계층을 캡슐화할 수 있기 때문이다. 캡슐화를 함으로써, 계층별로 담당하는 역할을 나눌 수 있다. 계층에 존재하는 각 프로토콜은 자신의 기능만 충실히 하여 독립성을 보장한다. 1-&gt;7로 이동하며 헤더가 붙고, 7-&gt;1로 이동하며 헤더를 풀어낸다.</p>
<h2 id="TCP-IP-4-계층"><a href="#TCP-IP-4-계층" class="headerlink" title="TCP/IP 4 계층"></a>TCP/IP 4 계층</h2><p>TCP/IP는 OSI 7계층을 단순화하여 4 계층으로 만들어서 사용한다.</p>
<p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/tcpip01.png" alt="img"></p>
<ol>
<li><p>Application Layer</p>
<p>OSI 7 계층의 Application Layer, Presentation Layer, Session Layer를 포함한다. 응용 프로그램들 간의 데이터 통신이 이루어지는 계층이다. SMTP, FTP, HTTP 등이 사용된다.</p>
</li>
<li><p>Transport Layer</p>
<p>인터넷 계층에서 결정한 목적지까지 실제 데이터를 신뢰성 있게 전송하는 역할을 한다. TCP와 UDP 등이 사용된다.</p>
</li>
<li><p>Internet Layer</p>
<p>데이터의 경로를 배정하는일(라우팅)을 담당한다. 데이터를 정확히 라우팅하기 위해 IP 등이 사용된다.</p>
</li>
<li><p>Pysical Layer</p>
<p>이더넷 카드와 같은 하드웨어이다. 인터넷 계층에서 형성된 패킷을 전기신호 또는 광신호로 바꾸어 전달한다.</p>
</li>
</ol>
<h2 id="TCP-연결-및-해제"><a href="#TCP-연결-및-해제" class="headerlink" title="TCP 연결 및 해제"></a>TCP 연결 및 해제</h2><p>TCP/IP 프로토콜은 OS 안에 라리브러로 내장되어 있다. 따라서 연결을 위한 3 way handshake 와 연결 해제를 위한 4 way handshake 는 OS가 처리한다. 프로그래머는 커널 내부를 몰라도 Socket 을 통해 TCP/IP를 사용할 수 있다. 즉, Socket은 Application Layer 에서 TCP/IP를 사용할 수 있도록 하는 인터페이스 역할을 한다.</p>
<p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/tcpip02.png" alt="img"></p>
<h2 id="3-way-handshake"><a href="#3-way-handshake" class="headerlink" title="3 way handshake"></a>3 way handshake</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/tcpip03.png" alt="img"></p>
<p>클라이언트와 서버의 연결 3 way handshake를 통해 이루어진다. </p>
<ol>
<li>연결을 하기 전 클라이언트는 Closed 상태이고, 서버는 요청을 기다리고 있는 LISTEN 상태이다.</li>
<li>클라이언트는 서버에 연결을 요청하는 SYN (M) 패킷을 보낸다.</li>
<li>서버는 클라이언트의 요청인 SYN (m)을 받고 클라이언트에게 요청을 수락한다는 ACK (M+1) 과  클라이언트 쪽에서도 포트를 열어 달라는 SYN (N) 패킷을 보낸다. 서버는 클라이언트의 응답을 기다리는 상대방의 응답을 기다리는 SYN_RCV로 상태가 된다.</li>
<li>클라이언트는 서버의 수락 응답은 ACK (M+1) 과 SYN (N) 패킷을 받고 포트를 열고 ACK (N+1) 을 서버로 보내면서 ESTABLISHED 상태가 된다.</li>
<li>ACK 데이터를 받은 서버 역시 ESTBALISHED 상태로 변경되면서, 클라이언트와 서버는 연결이 된다.</li>
</ol>
<h2 id="4-way-handshake"><a href="#4-way-handshake" class="headerlink" title="4 way handshake"></a>4 way handshake</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/tcpip04.png" alt="img"></p>
<p>연결 해제는 4 way handshake를 한다.</p>
<ol>
<li>초기에, 서버와 클라이언트는 ESTABLISHED 상태이다.</li>
<li>클라이언트는 연결을 종료하겠다는 FIN 플래그를 보낸다. ACK를 기다리고 있다는 의미로 FIN_WAIT_1 상태가 된다.</li>
<li>서버는 알겠다는 의미로 클라이언트에 ACK를 보내고, 애플리케이션의 소켓을 닫는다. 이 때, 남아있는 데이터를 모두 보낸다. 자원을 정리하는데 시간이 소요 되므로, 소켓을 닫는데 기다리고 있는 상태라는 의미에서 CLOSE_WAIT 상태가 된다. 연결 종료를 요청한 클라이언트는 서버로부터 응답이 올 때까지 기다리고 있다는 FIN_WAIT_2 상태가 된다.</li>
<li>데이터를 모두 보내고 통신이 끝났으면 연결이 종료 되었다고 클라이언트에게 FIN 플래그를 보낸다. 그리고 자신은 클라이언트로부터 마지막 ACK를 기다리고 있는 LAST_ACK 상태가 된다.</li>
<li>클라이언트는 FIN 데이터를 받으면 TIME_WAIT 상태로 바꾸면서 서버에 ACK 데이터를 보낸다. 클라이언트는 TIME_WATE 상태에서 일정 시간이 되면 CLOSED 상태가 된다. 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간 세션을 남겨놓고 잉여 패킷을 기다리는 것이다.</li>
<li>ACK 데이터를 받은 서버는 소켓 연결을 close하고 CLOSED 상태가 된다.</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kojunhee.github.io/2018/11/08/TCP:IP/" data-id="cjp7vlcfs00ilzjx7c6dymm7p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/36/">36</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/DIP/">DIP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DesignPattern/">DesignPattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/boostcourse/">boostcourse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cs/">cs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/dataStructure/">dataStructure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">database</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios/">ios</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/softwareEngineering/">softwareEngineering</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/22/Components/">Components</a>
          </li>
        
          <li>
            <a href="/2018/11/21/flow, congestion control/">flow, congestion control</a>
          </li>
        
          <li>
            <a href="/2018/11/21/flow control/">flow control</a>
          </li>
        
          <li>
            <a href="/2018/11/21/길찾기/">길찾기</a>
          </li>
        
          <li>
            <a href="/2018/11/13/SOLID/">SOLID</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>