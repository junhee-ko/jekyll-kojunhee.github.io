
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="junhee.ko">
    <title>Memory Management - junhee.ko</title>
    <meta name="author" content="junhee.ko">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"junhee.ko","sameAs":["https://github.com/kojunhee","https://facebook.com/kojunheee","https://www.linkedin.com/in/junheeko","mailto"]},"articleBody":"출처 : 이화여자대학교 반효경 (http://www.kocw.net/home/search/kemView.do?kemId=1046323)\nLogical vs Physical Address\nLogical address (=virtual address)\n\n프로세스마다 독립적으로 가지는 주소 공간\n각 프로세스마다 0번지 부터 시작\nCPU가 보는 주소는 logical address임 \n\n\nphysical address \n\n메모리에 실제 올라가는 위치 \n\n\n주소바인딩 : 주소를 결정하는 것\n\nSymbolic address -&gt;Logical Address -&gt; Physical address\n\n\n\nAddress Binding\n컴파일 타임 바인딩이나 로드 타임 바인딩 모두 실행될때 물리주소가 결정되지만, \n런타임 바인딩은 실행 이후에도 물리 주소가 바뀔 수 있다.\n소스코드 : A위치에 있는 값과 B위치에 값을 더해서 A에 저장해라. C위치로 점프해라\n\nCompile time binding\n물리적 메모리 주소가 컴파일 시 알려짐\n시작 위치 변경시 재컴파일\n컴파일러는 절대코드(absolute code) 생성\n\n\nLoad time binding\nLoader의 책임 하에 물리적 주소 부여\n컴파일러가 재배치가능코드를 생성하는 경우 가능\n\n\nExecution time binding(run time binding)\n수행이 시작된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있음\nCPU가 주소를 참조할 때마다 binding을 점검\n하드웨어적인 자원이 필요 (base and limit registers, MMU)\n\n\n\nMemory-Management Unit (MMU)logical address를 physical address로 매핑해 주는 hardware device\n\nMMU scheme\n사용자 프로세스가 CPU에서 수행되며 생성해내는 모든 주소값에 대해 base regiseter(relocation register)의 값을 더한다.\n\n\nuser program\nlogical address만을 다룬다\n실제 physical address를 볼수 없으며 알 필요가 없다.\n\n\n\nDynamic Relocation\nCPU가 프로세스 p1의 346번지를 요청한 상태.\n프로세스1은 물리주소 14000번지에 올라가있음.\n논리주소에 시작위치(relocation register)를 더해서 14346 구함.\n한가지 더 체크하는 것은?\n프로세스 p1의 크기를 limit register가 가지고 있어.\nCPU가 남의 프로그램의 메모리를 보려고 하는 시도를 막을 수 있음.\n\nlimit register : CPU가 요청하는 논리주소가 프로그램 크기보다 큰  논리 주소를 요청한 것은 아닌지 먼저 체크 \nDynamic Loading프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 load 하는 것\n\nmemory utilization 향상\n가끔씩 사용되는 많은 양의 코드의 경우 유용 (ex) 오류 처리 루틴\n운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능 (OS는 라이브러리를 통해 지원 가능)\nLoading : 메모리로 올리는 것\n\nOverlays메모리에 프로세스 부분 중 실제 필요한 정보많을 올림\n프로세스의 크기가 메모리보다 클 때 유용\n운영체제의 지원없이 사용자에 의해 구현\n작은 공간의 메모리를 사용하던 초창기 시스템에서 수작으로 프로그래머가 구현\nManual Overlay\n프로그램이 매우 복잡\nSwapping프로세스를 일시적으로 메모리에서 backing store로 쫓아내는것\n\n\nbacking store (swap area)\n디스크\n많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간\n\n\nSwap in / Swap out\n일반적으로 중기 스케쥴러에 의해 swap out 시킬 프로세스 선정\nCPU 우선순위가 낮은 프로세스를 swapped out 시킴\nCompile time 혹은 Load time binding 에서는 원래 메모리 위치로 swap in 해야함\nExecution time binding 에서는 추후 빈 메모리 영역 아무 곳에서나 올릴 수 있음 \nswap time은 대부분 transfer time (swap 되는 양에 비례하는 시간) 임\n\n\n\nDynamic LinkingLinking : 여러 군데 존재하던 컴파일된 파일들을 묶어서 실행 파일 만드는 것\n\nstatic linking \n라이브러리가 프로그램의 실행 파일 코드에 포함됨\n실행 파일의 크기가 커짐\n동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비 (ex. printf 함수의 라이브러리 코드)\n\n\ndynamic linking\n라이브러리가 실행시 연결됨\n라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 줌 (라이브러리 위치 찾을 수 있는)\n라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고 없으면 디스크에서 읽어옴\n운영체제의 도움이 필요\n\n\n\nAllocation of Physical Memory\n메모리는 일반적으로 두 영역으로 나뉘어 사용\nOS 상주 영역 \ninterrupt vector와 함께 낮은 주소 영역 사용\n\n\n사용자 프로세스 영역\n높은 주소 영역\n\n\n\n\n사용자 프로세스 영역의 할당 방법\nContiguous allocation\n각각의 프로세스가 메모리의 연속적인 공간에 적재되록 하는 것\n고정분할방식 / 가변분할방식\n\n\nNoncontiguous allocation\n하나의 프로세스가 메모리 영역에 분산되어 올라 갈수 있음\nPaging / Segmentaion / Paged Segmentation\n\n\n\n\n\nContiguous Allocation\n\n고정 분할 방식\n물리적 메모리를 몇 개의 영구적 분할(partition) 로 나눔\n분할의 크기가 모두 동일한 방힉과 서로  다른 방식이 존재\n분할당 하나의 프로그램 적재\n융통성 없음\n동시에 메모리에 load되는 프로그램의 수가 고정됨\n최대 수행 가능 프로그램 크기 제한\n\n\ninternal fragmentation, external fragmentation 발생\n\n\n가변 분할 방식\n프로그램이 실핼될때마다 차곡차곡 메모리에 올려\n프로그램의 크기를 고려해서 할당\n분할의 크기, 개수가 동적으로 변함\n기술적 관리 기법 필요\nexternal fragmenation 발생\n\n\n\nHole\n\n가용 메모리 공간\n\n가변분할 방식에서 생김\n\n다양한 크기의 hole들이 메모리 여러 곳에 흩어져 있음\n프로세스가 도착하면 수용 가능한 hole을 할당\n운영체제는 다음의 정보를 유지\n\n할당공간(프로그램이 사용하고 있는)\n가용공간(hole)\n\n\nDynamic Storage-Allocation Problem\n\n가변 분할 방식에서 size n인 요청을 만족하는 가장 적절한 hole을 찾는 문제\nFirst-fit \nSize가 n이상인 것 중 최초로 찾아지는 Hole에 할당\n\n\nBest-fit\nSize가 n이상인 가장 작은 hole을 찾아서 할당\nhole들의 리스트가 크기 순으로 정렬되지 않은 경우 모든 hole의 리스트를 탐색해야함\n많은 수의 아주 작은 hole들이 생성됨\n\n\nWorst-fit\n가장 큰 hole에 할당\n역시 모든 리스트를 탐색해야함\n상대적으로 아주 큰 hole들이 생성됨\n\n\n\n\nCompaction\nexternal fragmentation 문제를 해결하는 방법\n사용 중인 메모리 영역을 한구데로 몰고 hole들을 다 한곳으로 몰아 큰 block을 만드는 것\n매우 큰 비용이 드는 방법\n프로세스의 주소가 실행 시간에 동적으로 재배치 가능한 경우에만 수행될 수 있음\n\n\n\nPaging\n\n\nProcess의 virtual memory를 동일한 사이즈의 page 단위로 나눔\nvirtual memory의 내용이 page 단위로 noncontiguous하게 저장됨\n일부는 backing storage에 일부는 physical memory에 저장\nBasic method\n\nphysical memory를 동일한 크기의 frame으로 나눔\nlogical memory를 동일 크기의 page로 나눔 (frame과 같은 크기)\n모든 가용 frame들을 관리\npage table을 사용하여 logical address를 physical address로 변환\nexternal fragmentation 발생 안함\ninternal fragmentation 발생가능\n\n\npage table\n\n페이지들이 물리적인 메모리 어디에 올라가 있나\nlogical memory의 page 개수 만큼 entry 가 존재\n\n\nlogical address\n\np : page 번호\nd: 그 페이지 내에서 얼만큼 떨어져 있나\n\n\n\nImplementation of Page Table\nPage table은 main memory 에 상주\n\nPage table base register (PTBR) 가 page table을 가리킴\n\nPage table length register (PTLR) 가 테이블 크기를 보관\n\n모든 메모리 접근 연산에는 2번의 memory access 필요\n\npage table 접근 1번\n실제 data/instruction 접근  1번\n\n\n속도 향상을 위해 associative register / translation look-aside buffter(TLB)\n라 불리는 고속의 lookup hardware cache 사용\n\n\nPaging Hardware with TLB\n 주소 변환을 위한 케쉬 메모리. \n빈번히 참조되는 엔트리 몇개 만을 가지고 있음.\n전체 항목을 검색해야봐야함.  여기 어디에도 없으면 page table을 봄\nTLB에서 전체 항목을 다 검색해야하기 때문에, parallel search로 빠르게 함. 병력적으로 한번에 쫙 검색함.\nTwo-Level Page Table\npage table이 2단계. \n속도는 더 걸림. page table을 위한 공간은 줄어듦. \n주소공간에서 실제로 사용되지 않는 페이지에 대해서는 안쪽 테이블이 안만들어져.\n\n\np1 \n10bit\nouter page table의 index\n\n\np2\n10bit\nouter page table의 page에서의 변위(displacement)\n\n\n\n\nMultilevel Paging and PerformanceAddress space가 더 커지면 다단게 페이지 테이블이 필요.\n각 단계의 페이지 테이블이 메모리에 존재하므로 logical address의 physical address 변환에 더 많은 메모리 접근 필요.\nTLB를 통해 메모리 접근 시간을 줄일 수 있음.\nValid / Invalid Bit in a Page Table\n\nprotection bit\npage에 대한 접근 권한 (read /write / read-only)\n\n\nvalid\n해당 주소의 frame에 그 프로세스를 구성하는 유요한 내용이 있음\n\n\ninvalid\n프로세스가 그 주소 부분을 사용하지 않는 경우 \n해당 페이지가 메모리에 올라와 있지 않고 swap area에 있는 경우\n\n\n\nInverted Page Table\n\nPage table이 매우 큰 이유\n\n모든 process 별로 그 logical address에 대응하는 모든 page에 대해 page table entry 존재\n대응하는 page가 메모리에 있든 아니든 간에 page table에는 entry로 존재\n\n\ninverted page table\n\nPage frame 하나당 page table에 하나의 entry를 둔것\n\n각 page table entry는 각각의 물리적 메모리의 page frame이 담고 있는 내용 표시\n(process-id, process의 logical address)\n\npage frame 개수만큼 entry 존재.\n\nentry 전부 검색해서 pid랑 p 찾아야함. associative registe 찾아서 병렬 검색을 함\n\n단점\n\n테이블 전체를 탐색\n\n\n조치\n\nassociative register 사용 (expensive)\n\n\n\n\n\nShared Page\n공유할 수 있는 코드는 같은 프레임으로 매핑 시켜서 메모리에 한 카피만 올려\n\nShared code\n\nRe-entrant Code (= Pure code)\n\nread-only 로 하여 프로세스 간에 하나의 code만 메모리에 올림\n(eg, text editords, compilers, window systems)\n\nShared code는 모든 프로세스의 logical address space에서 동일한 위치에 있어야함\n\n위 그림에서, ed1, 2, 3 순으로 되어야 함\n\n\n\n\nPrivate code and data\n\n각 프로세스들은 독자적으로 메모리에 올림\nprivate data는 logical addreess space 의 아무 곳에 와도 무방\n\n\n\nSegmentation\n프로그램은 의미 단위인 여러 개의 segment로 구성\n작게는  프로그램을 구성하는 함수 하나하나를 세그먼트로 정의\n크게는 프로그램 전체를 하나의 세그먼트로 정의 가능\n일반적으로 code, data, stack 부분이 하나씩 세그먼트로 정의됨\nSegment는 의미 단위 이기 떄문에 공유와 보안에 있어서 paging 보다 효과적\nSegment의 길이가 동일하지 않으므로 가변 분할 방식에서와 동일한 문제점들이 발생\n\nLogical address는 다음의 두가지로 구성\n&lt;segment-number, offset&gt;\n\n\nSegment table\n\neach table entry has\nbase : starting physical address of the segment\nlimit : length of the segment\n\n\nSegment-table base reigster (STLR)\n물리적 메모리에서의 segment table의 위치 \n\n\nSegment-table length reigster (STLR)\n프로그램이 사용하는 segment의 수\n\n\n\n\n체크\n\n세그먼트 번호가 STLR 보다 작은지 체크해야함 \n세그먼트의 길이보다 세그먼트안에서 떨어진 offset 값이 더 크지는 않은가\n\n\n\nSegmentation Example\n다섯 개의 segment. 각각의 세그먼트에 대해서 주소 변환을 위한 테이블이 있음\nSharing of Segments\n0번 세그먼트는 같은 역할을 하는 세그먼트. 이 두 개의 세그먼트는 같은 물리주소에 올라감.\n1번 세그먼트는 다른 물리주소에 올라감.\nSegmentation with Paging\n세그먼트 하나가 여러개의 페이지로 구성\n먼저 세그먼트에 대해 주소 변환\nlogical address : 세그먼트 번호와 세그먼트 안에서 얼마나 떨어있는지\nSTBR에 세그먼트 시작 위치가들어있고, 거기서부터 위에서부터 s번째 엔트리에 가면 page table의 시작 위치가 나옴\n 세그먼트의 길이보다 세그먼트 안에서 떨어진 offset이 크다면 잘못된 요청\nd는 page 번호와 page 안에서 얼마나 떨어져 있는지 (p, d`)\npage table의 시작 위치로부터 page 번호 만큼 떨어진 엔트리에 가면 이 페이지에 대한 주소 변환 결과 (물리적인 메모리의 몇번째 프레임인지) 나와\n\npure segmentation 과 차이점\nsegment-table entry가 segment의 base address를 가지고있는 것이 아니라, segment를 구서하는 page table의 base address를 가지고 있음\n\n\n\n주소 변환을 위한 OS의 역할어떤 프로세스가 CPU를 가지고 메모리 접근을 하는데, \n주소 변환을 할 때 마다 운영체제가 중간에 개입하면 CPU가 이 프로세스로부터 운영체제에게 넘어가야돼.\n주소 변환 다 했으니까 다시 CPU가 이 프로세스에게 넘어온다? 말이 안돼. \n주소 변환은 무조건 하드웨어적으로 일어남. IO 장치에 접근하려면 OS가 끼어들어야돼.\n","dateCreated":"2018-10-09T00:00:00+09:00","dateModified":"2018-10-10T18:26:37+09:00","datePublished":"2018-10-09T00:00:00+09:00","description":"","headline":"Memory Management","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://junheeko.com/2018/10/09/2018-10-09-Memory Management/"},"publisher":{"@type":"Organization","name":"junhee.ko","sameAs":["https://github.com/kojunhee","https://facebook.com/kojunheee","https://www.linkedin.com/in/junheeko","mailto"]},"url":"http://junheeko.com/2018/10/09/2018-10-09-Memory Management/"}</script>
    <meta name="description" content="출처 : 이화여자대학교 반효경 (http://www.kocw.net/home/search/kemView.do?kemId=1046323) Logical vs Physical Address Logical address (=virtual address)  프로세스마다 독립적으로 가지는 주소 공간 각 프로세스마다 0번지 부터 시작 CPU가 보는 주소는 logica">
<meta property="og:type" content="blog">
<meta property="og:title" content="Memory Management">
<meta property="og:url" content="http://junheeko.com/2018/10/09/2018-10-09-Memory Management/index.html">
<meta property="og:site_name" content="junhee.ko">
<meta property="og:description" content="출처 : 이화여자대학교 반효경 (http://www.kocw.net/home/search/kemView.do?kemId=1046323) Logical vs Physical Address Logical address (=virtual address)  프로세스마다 독립적으로 가지는 주소 공간 각 프로세스마다 0번지 부터 시작 CPU가 보는 주소는 logica">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm01.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm02.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm03.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm04.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm05.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm06.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm07.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm08.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm09.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm10.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm11.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm12.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm13.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm14.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm15.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm16.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm17.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm18.png">
<meta property="og:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm19.png">
<meta property="og:updated_time" content="2018-10-10T09:26:37.197Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Memory Management">
<meta name="twitter:description" content="출처 : 이화여자대학교 반효경 (http://www.kocw.net/home/search/kemView.do?kemId=1046323) Logical vs Physical Address Logical address (=virtual address)  프로세스마다 독립적으로 가지는 주소 공간 각 프로세스마다 0번지 부터 시작 CPU가 보는 주소는 logica">
<meta name="twitter:image" content="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm01.png">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-du2xmrqdqrl2ollgeiw050kpl6l4nbyz7bumjuurjgsxyopifvukebxc9lqe.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">junhee.ko</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="Home">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="Categories">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="Tags">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" title="Archives">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/kojunhee" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://facebook.com/kojunheee" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://www.linkedin.com/in/junheeko" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/mailto" title="Mail">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Memory Management
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-10-09T00:00:00+09:00">
	
		    Oct 09, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/OS/">OS</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>출처 : 이화여자대학교 반효경 (<a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323" target="_blank" rel="noopener">http://www.kocw.net/home/search/kemView.do?kemId=1046323</a>)</p>
<h2 id="Logical-vs-Physical-Address"><a href="#Logical-vs-Physical-Address" class="headerlink" title="Logical vs Physical Address"></a>Logical vs Physical Address</h2><ul>
<li><p>Logical address (=virtual address)</p>
<ul>
<li>프로세스마다 독립적으로 가지는 주소 공간</li>
<li>각 프로세스마다 0번지 부터 시작</li>
<li>CPU가 보는 주소는 logical address임 </li>
</ul>
</li>
<li><p>physical address </p>
<ul>
<li>메모리에 실제 올라가는 위치 </li>
</ul>
</li>
<li><p>주소바인딩 : 주소를 결정하는 것</p>
<ul>
<li>Symbolic address -&gt;Logical Address -&gt; Physical address</li>
</ul>
</li>
</ul>
<h2 id="Address-Binding"><a href="#Address-Binding" class="headerlink" title="Address Binding"></a>Address Binding</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm01.png" alt="img"></p>
<p>컴파일 타임 바인딩이나 로드 타임 바인딩 모두 실행될때 물리주소가 결정되지만, </p>
<p>런타임 바인딩은 실행 이후에도 물리 주소가 바뀔 수 있다.</p>
<p>소스코드 : A위치에 있는 값과 B위치에 값을 더해서 A에 저장해라. C위치로 점프해라</p>
<ul>
<li>Compile time binding<ul>
<li>물리적 메모리 주소가 컴파일 시 알려짐</li>
<li>시작 위치 변경시 재컴파일</li>
<li>컴파일러는 절대코드(absolute code) 생성</li>
</ul>
</li>
<li>Load time binding<ul>
<li>Loader의 책임 하에 물리적 주소 부여</li>
<li>컴파일러가 재배치가능코드를 생성하는 경우 가능</li>
</ul>
</li>
<li>Execution time binding(run time binding)<ul>
<li>수행이 시작된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있음</li>
<li>CPU가 주소를 참조할 때마다 binding을 점검</li>
<li>하드웨어적인 자원이 필요 (base and limit registers, MMU)</li>
</ul>
</li>
</ul>
<h2 id="Memory-Management-Unit-MMU"><a href="#Memory-Management-Unit-MMU" class="headerlink" title="Memory-Management Unit (MMU)"></a>Memory-Management Unit (MMU)</h2><p>logical address를 physical address로 매핑해 주는 hardware device</p>
<ul>
<li>MMU scheme<ul>
<li>사용자 프로세스가 CPU에서 수행되며 생성해내는 모든 주소값에 대해 base regiseter(relocation register)의 값을 더한다.</li>
</ul>
</li>
<li>user program<ul>
<li>logical address만을 다룬다</li>
<li>실제 physical address를 볼수 없으며 알 필요가 없다.</li>
</ul>
</li>
</ul>
<h2 id="Dynamic-Relocation"><a href="#Dynamic-Relocation" class="headerlink" title="Dynamic Relocation"></a>Dynamic Relocation</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm02.png" alt="img"></p>
<p>CPU가 프로세스 p1의 346번지를 요청한 상태.</p>
<p>프로세스1은 물리주소 14000번지에 올라가있음.</p>
<p>논리주소에 시작위치(relocation register)를 더해서 14346 구함.</p>
<p>한가지 더 체크하는 것은?</p>
<p>프로세스 p1의 크기를 limit register가 가지고 있어.</p>
<p>CPU가 남의 프로그램의 메모리를 보려고 하는 시도를 막을 수 있음.</p>
<p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm03.png" alt="img"></p>
<p>limit register : CPU가 요청하는 논리주소가 프로그램 크기보다 큰  논리 주소를 요청한 것은 아닌지 먼저 체크 </p>
<h2 id="Dynamic-Loading"><a href="#Dynamic-Loading" class="headerlink" title="Dynamic Loading"></a>Dynamic Loading</h2><p>프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 load 하는 것</p>
<ul>
<li>memory utilization 향상</li>
<li>가끔씩 사용되는 많은 양의 코드의 경우 유용 (ex) 오류 처리 루틴</li>
<li>운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능 (OS는 라이브러리를 통해 지원 가능)</li>
<li>Loading : 메모리로 올리는 것</li>
</ul>
<h2 id="Overlays"><a href="#Overlays" class="headerlink" title="Overlays"></a>Overlays</h2><p>메모리에 프로세스 부분 중 실제 필요한 정보많을 올림</p>
<p>프로세스의 크기가 메모리보다 클 때 유용</p>
<p>운영체제의 지원없이 사용자에 의해 구현</p>
<p>작은 공간의 메모리를 사용하던 초창기 시스템에서 수작으로 프로그래머가 구현</p>
<p>Manual Overlay</p>
<p>프로그램이 매우 복잡</p>
<h2 id="Swapping"><a href="#Swapping" class="headerlink" title="Swapping"></a>Swapping</h2><p>프로세스를 일시적으로 메모리에서 backing store로 쫓아내는것</p>
<p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm04.png" alt="img"></p>
<ul>
<li>backing store (swap area)<ul>
<li>디스크</li>
<li>많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간</li>
</ul>
</li>
<li>Swap in / Swap out<ul>
<li>일반적으로 중기 스케쥴러에 의해 swap out 시킬 프로세스 선정</li>
<li>CPU 우선순위가 낮은 프로세스를 swapped out 시킴</li>
<li>Compile time 혹은 Load time binding 에서는 원래 메모리 위치로 swap in 해야함</li>
<li>Execution time binding 에서는 추후 빈 메모리 영역 아무 곳에서나 올릴 수 있음 </li>
<li>swap time은 대부분 transfer time (swap 되는 양에 비례하는 시간) 임</li>
</ul>
</li>
</ul>
<h2 id="Dynamic-Linking"><a href="#Dynamic-Linking" class="headerlink" title="Dynamic Linking"></a>Dynamic Linking</h2><p>Linking : 여러 군데 존재하던 컴파일된 파일들을 묶어서 실행 파일 만드는 것</p>
<ul>
<li>static linking <ul>
<li>라이브러리가 프로그램의 실행 파일 코드에 포함됨</li>
<li>실행 파일의 크기가 커짐</li>
<li>동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비 (ex. printf 함수의 라이브러리 코드)</li>
</ul>
</li>
<li>dynamic linking<ul>
<li>라이브러리가 실행시 연결됨</li>
<li>라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 줌 (라이브러리 위치 찾을 수 있는)</li>
<li>라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고 없으면 디스크에서 읽어옴</li>
<li>운영체제의 도움이 필요</li>
</ul>
</li>
</ul>
<h2 id="Allocation-of-Physical-Memory"><a href="#Allocation-of-Physical-Memory" class="headerlink" title="Allocation of Physical Memory"></a>Allocation of Physical Memory</h2><ul>
<li>메모리는 일반적으로 두 영역으로 나뉘어 사용<ul>
<li>OS 상주 영역 <ul>
<li>interrupt vector와 함께 낮은 주소 영역 사용</li>
</ul>
</li>
<li>사용자 프로세스 영역<ul>
<li>높은 주소 영역</li>
</ul>
</li>
</ul>
</li>
<li>사용자 프로세스 영역의 할당 방법<ul>
<li>Contiguous allocation<ul>
<li>각각의 프로세스가 메모리의 연속적인 공간에 적재되록 하는 것</li>
<li>고정분할방식 / 가변분할방식</li>
</ul>
</li>
<li>Noncontiguous allocation<ul>
<li>하나의 프로세스가 메모리 영역에 분산되어 올라 갈수 있음</li>
<li>Paging / Segmentaion / Paged Segmentation</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Contiguous-Allocation"><a href="#Contiguous-Allocation" class="headerlink" title="Contiguous Allocation"></a>Contiguous Allocation</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm05.png" alt="img"></p>
<ul>
<li>고정 분할 방식<ul>
<li>물리적 메모리를 몇 개의 영구적 분할(partition) 로 나눔</li>
<li>분할의 크기가 모두 동일한 방힉과 서로  다른 방식이 존재</li>
<li>분할당 하나의 프로그램 적재</li>
<li>융통성 없음<ul>
<li>동시에 메모리에 load되는 프로그램의 수가 고정됨</li>
<li>최대 수행 가능 프로그램 크기 제한</li>
</ul>
</li>
<li>internal fragmentation, external fragmentation 발생</li>
</ul>
</li>
<li>가변 분할 방식<ul>
<li>프로그램이 실핼될때마다 차곡차곡 메모리에 올려</li>
<li>프로그램의 크기를 고려해서 할당</li>
<li>분할의 크기, 개수가 동적으로 변함</li>
<li>기술적 관리 기법 필요</li>
<li>external fragmenation 발생</li>
</ul>
</li>
</ul>
<h2 id="Hole"><a href="#Hole" class="headerlink" title="Hole"></a>Hole</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm06.png" alt="img"></p>
<ul>
<li><p>가용 메모리 공간</p>
</li>
<li><p>가변분할 방식에서 생김</p>
</li>
<li>다양한 크기의 hole들이 메모리 여러 곳에 흩어져 있음</li>
<li>프로세스가 도착하면 수용 가능한 hole을 할당</li>
<li><p>운영체제는 다음의 정보를 유지</p>
<ul>
<li>할당공간(프로그램이 사용하고 있는)</li>
<li>가용공간(hole)</li>
</ul>
</li>
<li><p>Dynamic Storage-Allocation Problem</p>
<ul>
<li>가변 분할 방식에서 size n인 요청을 만족하는 가장 적절한 hole을 찾는 문제</li>
<li>First-fit <ul>
<li>Size가 n이상인 것 중 최초로 찾아지는 Hole에 할당</li>
</ul>
</li>
<li>Best-fit<ul>
<li>Size가 n이상인 가장 작은 hole을 찾아서 할당</li>
<li>hole들의 리스트가 크기 순으로 정렬되지 않은 경우 모든 hole의 리스트를 탐색해야함</li>
<li>많은 수의 아주 작은 hole들이 생성됨</li>
</ul>
</li>
<li>Worst-fit<ul>
<li>가장 큰 hole에 할당</li>
<li>역시 모든 리스트를 탐색해야함</li>
<li>상대적으로 아주 큰 hole들이 생성됨</li>
</ul>
</li>
</ul>
</li>
<li>Compaction<ul>
<li>external fragmentation 문제를 해결하는 방법</li>
<li>사용 중인 메모리 영역을 한구데로 몰고 hole들을 다 한곳으로 몰아 큰 block을 만드는 것</li>
<li>매우 큰 비용이 드는 방법</li>
<li>프로세스의 주소가 실행 시간에 동적으로 재배치 가능한 경우에만 수행될 수 있음</li>
</ul>
</li>
</ul>
<h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm07.png" alt="img"></p>
<p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm08.png" alt="img"></p>
<ul>
<li>Process의 virtual memory를 동일한 사이즈의 page 단위로 나눔</li>
<li>virtual memory의 내용이 page 단위로 noncontiguous하게 저장됨</li>
<li>일부는 backing storage에 일부는 physical memory에 저장</li>
<li><p>Basic method</p>
<ul>
<li>physical memory를 동일한 크기의 frame으로 나눔</li>
<li>logical memory를 동일 크기의 page로 나눔 (frame과 같은 크기)</li>
<li>모든 가용 frame들을 관리</li>
<li>page table을 사용하여 logical address를 physical address로 변환</li>
<li>external fragmentation 발생 안함</li>
<li>internal fragmentation 발생가능</li>
</ul>
</li>
<li><p>page table</p>
<ul>
<li>페이지들이 물리적인 메모리 어디에 올라가 있나</li>
<li>logical memory의 page 개수 만큼 entry 가 존재</li>
</ul>
</li>
<li><p>logical address</p>
<ul>
<li>p : page 번호</li>
<li>d: 그 페이지 내에서 얼만큼 떨어져 있나</li>
</ul>
</li>
</ul>
<h2 id="Implementation-of-Page-Table"><a href="#Implementation-of-Page-Table" class="headerlink" title="Implementation of Page Table"></a>Implementation of Page Table</h2><ul>
<li><p>Page table은 main memory 에 상주</p>
</li>
<li><p>Page table base register (PTBR) 가 page table을 가리킴</p>
</li>
<li><p>Page table length register (PTLR) 가 테이블 크기를 보관</p>
</li>
<li><p>모든 메모리 접근 연산에는 2번의 memory access 필요</p>
<ul>
<li>page table 접근 1번</li>
<li>실제 data/instruction 접근  1번</li>
</ul>
</li>
<li><p>속도 향상을 위해 associative register / translation look-aside buffter(TLB)</p>
<p>라 불리는 고속의 lookup hardware cache 사용</p>
</li>
</ul>
<h2 id="Paging-Hardware-with-TLB"><a href="#Paging-Hardware-with-TLB" class="headerlink" title="Paging Hardware with TLB"></a>Paging Hardware with TLB</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm09.png" alt="img"></p>
<p> 주소 변환을 위한 케쉬 메모리. </p>
<p>빈번히 참조되는 엔트리 몇개 만을 가지고 있음.</p>
<p>전체 항목을 검색해야봐야함.  여기 어디에도 없으면 page table을 봄</p>
<p>TLB에서 전체 항목을 다 검색해야하기 때문에, parallel search로 빠르게 함. 병력적으로 한번에 쫙 검색함.</p>
<h2 id="Two-Level-Page-Table"><a href="#Two-Level-Page-Table" class="headerlink" title="Two-Level Page Table"></a>Two-Level Page Table</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm10.png" alt="img"></p>
<p>page table이 2단계. </p>
<p>속도는 더 걸림. page table을 위한 공간은 줄어듦. </p>
<p>주소공간에서 실제로 사용되지 않는 페이지에 대해서는 안쪽 테이블이 안만들어져.</p>
<p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm11.png" alt="img"></p>
<ul>
<li>p1 <ul>
<li>10bit</li>
<li>outer page table의 index</li>
</ul>
</li>
<li>p2<ul>
<li>10bit</li>
<li>outer page table의 page에서의 변위(displacement)</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm12.png" alt="img"></p>
<h2 id="Multilevel-Paging-and-Performance"><a href="#Multilevel-Paging-and-Performance" class="headerlink" title="Multilevel Paging and Performance"></a>Multilevel Paging and Performance</h2><p>Address space가 더 커지면 다단게 페이지 테이블이 필요.</p>
<p>각 단계의 페이지 테이블이 메모리에 존재하므로 logical address의 physical address 변환에 더 많은 메모리 접근 필요.</p>
<p>TLB를 통해 메모리 접근 시간을 줄일 수 있음.</p>
<h2 id="Valid-Invalid-Bit-in-a-Page-Table"><a href="#Valid-Invalid-Bit-in-a-Page-Table" class="headerlink" title="Valid / Invalid Bit in a Page Table"></a>Valid / Invalid Bit in a Page Table</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm13.png" alt="img"></p>
<ul>
<li>protection bit<ul>
<li>page에 대한 접근 권한 (read /write / read-only)</li>
</ul>
</li>
<li>valid<ul>
<li>해당 주소의 frame에 그 프로세스를 구성하는 유요한 내용이 있음</li>
</ul>
</li>
<li>invalid<ul>
<li>프로세스가 그 주소 부분을 사용하지 않는 경우 </li>
<li>해당 페이지가 메모리에 올라와 있지 않고 swap area에 있는 경우</li>
</ul>
</li>
</ul>
<h2 id="Inverted-Page-Table"><a href="#Inverted-Page-Table" class="headerlink" title="Inverted Page Table"></a>Inverted Page Table</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm14.png" alt="img"></p>
<ul>
<li><p>Page table이 매우 큰 이유</p>
<ul>
<li>모든 process 별로 그 logical address에 대응하는 모든 page에 대해 page table entry 존재</li>
<li>대응하는 page가 메모리에 있든 아니든 간에 page table에는 entry로 존재</li>
</ul>
</li>
<li><p>inverted page table</p>
<ul>
<li><p>Page frame 하나당 page table에 하나의 entry를 둔것</p>
</li>
<li><p>각 page table entry는 각각의 물리적 메모리의 page frame이 담고 있는 내용 표시</p>
<p>(process-id, process의 logical address)</p>
</li>
<li><p>page frame 개수만큼 entry 존재.</p>
</li>
<li><p>entry 전부 검색해서 pid랑 p 찾아야함. associative registe 찾아서 병렬 검색을 함</p>
</li>
<li><p>단점</p>
<ul>
<li>테이블 전체를 탐색</li>
</ul>
</li>
<li><p>조치</p>
<ul>
<li>associative register 사용 (expensive)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Shared-Page"><a href="#Shared-Page" class="headerlink" title="Shared Page"></a>Shared Page</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm15.png" alt="img"></p>
<p>공유할 수 있는 코드는 같은 프레임으로 매핑 시켜서 메모리에 한 카피만 올려</p>
<ul>
<li><p>Shared code</p>
<ul>
<li><p>Re-entrant Code (= Pure code)</p>
</li>
<li><p>read-only 로 하여 프로세스 간에 하나의 code만 메모리에 올림</p>
<p>(eg, text editords, compilers, window systems)</p>
</li>
<li><p>Shared code는 모든 프로세스의 logical address space에서 동일한 위치에 있어야함</p>
<ul>
<li>위 그림에서, ed1, 2, 3 순으로 되어야 함</li>
</ul>
</li>
</ul>
</li>
<li><p>Private code and data</p>
<ul>
<li>각 프로세스들은 독자적으로 메모리에 올림</li>
<li>private data는 logical addreess space 의 아무 곳에 와도 무방</li>
</ul>
</li>
</ul>
<h2 id="Segmentation"><a href="#Segmentation" class="headerlink" title="Segmentation"></a>Segmentation</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm16.png" alt="img"></p>
<p>프로그램은 의미 단위인 여러 개의 segment로 구성</p>
<p>작게는  프로그램을 구성하는 함수 하나하나를 세그먼트로 정의</p>
<p>크게는 프로그램 전체를 하나의 세그먼트로 정의 가능</p>
<p>일반적으로 code, data, stack 부분이 하나씩 세그먼트로 정의됨</p>
<p>Segment는 의미 단위 이기 떄문에 공유와 보안에 있어서 paging 보다 효과적</p>
<p>Segment의 길이가 동일하지 않으므로 가변 분할 방식에서와 동일한 문제점들이 발생</p>
<ul>
<li>Logical address는 다음의 두가지로 구성<ul>
<li>&lt;segment-number, offset&gt;</li>
</ul>
</li>
<li><p>Segment table</p>
<ul>
<li>each table entry has<ul>
<li>base : starting physical address of the segment</li>
<li>limit : length of the segment</li>
</ul>
</li>
<li>Segment-table base reigster (STLR)<ul>
<li>물리적 메모리에서의 segment table의 위치 </li>
</ul>
</li>
<li>Segment-table length reigster (STLR)<ul>
<li>프로그램이 사용하는 segment의 수</li>
</ul>
</li>
</ul>
</li>
<li><p>체크</p>
<ul>
<li>세그먼트 번호가 STLR 보다 작은지 체크해야함 </li>
<li>세그먼트의 길이보다 세그먼트안에서 떨어진 offset 값이 더 크지는 않은가</li>
</ul>
</li>
</ul>
<h2 id="Segmentation-Example"><a href="#Segmentation-Example" class="headerlink" title="Segmentation Example"></a>Segmentation Example</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm17.png" alt="img"></p>
<p>다섯 개의 segment. 각각의 세그먼트에 대해서 주소 변환을 위한 테이블이 있음</p>
<h2 id="Sharing-of-Segments"><a href="#Sharing-of-Segments" class="headerlink" title="Sharing of Segments"></a>Sharing of Segments</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm18.png" alt="img"></p>
<p>0번 세그먼트는 같은 역할을 하는 세그먼트. 이 두 개의 세그먼트는 같은 물리주소에 올라감.</p>
<p>1번 세그먼트는 다른 물리주소에 올라감.</p>
<h2 id="Segmentation-with-Paging"><a href="#Segmentation-with-Paging" class="headerlink" title="Segmentation with Paging"></a>Segmentation with Paging</h2><p><img src="https://github.com/KoJunHee/kojunhee.github.io/raw/master/img/mmmm19.png" alt="img"></p>
<p>세그먼트 하나가 여러개의 페이지로 구성</p>
<p>먼저 세그먼트에 대해 주소 변환</p>
<p>logical address : 세그먼트 번호와 세그먼트 안에서 얼마나 떨어있는지</p>
<p>STBR에 세그먼트 시작 위치가들어있고, 거기서부터 위에서부터 s번째 엔트리에 가면 page table의 시작 위치가 나옴</p>
<p> 세그먼트의 길이보다 세그먼트 안에서 떨어진 offset이 크다면 잘못된 요청</p>
<p>d는 page 번호와 page 안에서 얼마나 떨어져 있는지 (p, d`)</p>
<p>page table의 시작 위치로부터 page 번호 만큼 떨어진 엔트리에 가면 이 페이지에 대한 주소 변환 결과 (물리적인 메모리의 몇번째 프레임인지) 나와</p>
<ul>
<li>pure segmentation 과 차이점<ul>
<li>segment-table entry가 segment의 base address를 가지고있는 것이 아니라, segment를 구서하는 page table의 base address를 가지고 있음</li>
</ul>
</li>
</ul>
<h2 id="주소-변환을-위한-OS의-역할"><a href="#주소-변환을-위한-OS의-역할" class="headerlink" title="주소 변환을 위한 OS의 역할"></a>주소 변환을 위한 OS의 역할</h2><p>어떤 프로세스가 CPU를 가지고 메모리 접근을 하는데, </p>
<p>주소 변환을 할 때 마다 운영체제가 중간에 개입하면 CPU가 이 프로세스로부터 운영체제에게 넘어가야돼.</p>
<p>주소 변환 다 했으니까 다시 CPU가 이 프로세스에게 넘어온다? 말이 안돼. </p>
<p>주소 변환은 무조건 하드웨어적으로 일어남. IO 장치에 접근하려면 OS가 끼어들어야돼.</p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/10/11/2018-10-11-Virtual Memory/" data-tooltip="Virtual Memory" aria-label="PREVIOUS: Virtual Memory">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/10/09/2018-10-09-활주로 건설/" data-tooltip="활주로 건설" aria-label="NEXT: 활주로 건설">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://junheeko.com/2018/10/09/2018-10-09-Memory Management/" title="Share on Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://junheeko.com/2018/10/09/2018-10-09-Memory Management/" title="Share on Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://junheeko.com/2018/10/09/2018-10-09-Memory Management/" title="Share on Google+">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 junhee.ko. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/10/11/2018-10-11-Virtual Memory/" data-tooltip="Virtual Memory" aria-label="PREVIOUS: Virtual Memory">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/10/09/2018-10-09-활주로 건설/" data-tooltip="활주로 건설" aria-label="NEXT: 활주로 건설">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://junheeko.com/2018/10/09/2018-10-09-Memory Management/" title="Share on Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://junheeko.com/2018/10/09/2018-10-09-Memory Management/" title="Share on Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://junheeko.com/2018/10/09/2018-10-09-Memory Management/" title="Share on Google+">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-times"></i>
    <ul class="share-options">
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://junheeko.com/2018/10/09/2018-10-09-Memory Management/">
                    <i class="fab fa-facebook" aria-hidden="true"></i><span>Share on Facebook</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://junheeko.com/2018/10/09/2018-10-09-Memory Management/">
                    <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://junheeko.com/2018/10/09/2018-10-09-Memory Management/">
                    <i class="fab fa-google-plus" aria-hidden="true"></i><span>Share on Google+</span>
                </a>
            </li>
        
    </ul>
</div>

            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">junhee.ko</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-vufjrm3fmbuttogo1hxuu0w9w0sesk5iyysjuguc2hdhufot9szxg8twijry.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
